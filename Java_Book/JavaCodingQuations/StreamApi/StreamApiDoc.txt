ðŸ“˜ Java Streams â€“ Complete Notes
1. What is a Stream?

A Stream is a sequence of elements supporting functional-style operations.

Introduced in Java 8.

Streams do not store data â†’ they work on data from collections, arrays, I/O channels, etc.

Streams are lazy â†’ operations are executed only when a terminal operation is invoked.

2. Stream Pipeline

A Stream pipeline consists of:

Source â†’ Intermediate Operations â†’ Terminal Operation


Source â†’ Collection, Array, or I/O.

Intermediate Operations â†’ Transform/Filter the stream (return another stream).

Terminal Operation â†’ Produces result (returns non-stream).

Example:
List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");

names.stream()                            // Source
     .filter(name -> name.length() > 3)   // Intermediate
     .map(String::toUpperCase)            // Intermediate
     .forEach(System.out::println);       // Terminal

3. Stream Diagram (Text-Based)
Collection/Array/IO Source
        â”‚
        â–¼
+--------------------+
|   Stream pipeline  |
|--------------------|
| filter()           |
| map()              |
| sorted()           |
| distinct()         |
+--------------------+
        â”‚
        â–¼
Terminal Operation (forEach, collect, reduce, count...)

4. Types of Streams

Stream<T> â†’ Generic stream of objects.

IntStream, LongStream, DoubleStream â†’ Primitive streams (avoid boxing overhead).

5. Key Operations
Intermediate (return a Stream)

filter(Predicate<T>) â†’ keep elements matching condition

map(Function<T,R>) â†’ transform elements

sorted() / sorted(Comparator)

distinct() â†’ remove duplicates

limit(n) â†’ take first n elements

skip(n) â†’ skip first n elements

Terminal (end pipeline, return non-stream)

forEach(Consumer<T>)

collect(Collectors.toList(), toSet(), toMap(), joining(), groupingBy())

reduce() â†’ aggregate into single value

count() â†’ count elements

anyMatch(), allMatch(), noneMatch()

6. Default Functional Interfaces (java.util.function)

Java 8 provides functional interfaces â†’ used in lambda expressions & streams.

Core Interfaces

Function<T, R> â†’ takes T, returns R

Example: map(String::length)

Predicate<T> â†’ takes T, returns boolean

Example: filter(x -> x > 10)

Consumer<T> â†’ takes T, returns nothing

Example: forEach(System.out::println)

Supplier<T> â†’ takes nothing, returns T

Example: Supplier<Date> now = Date::new

Primitive Specializations

IntFunction<R>, IntPredicate, IntConsumer

LongFunction<R>, LongPredicate, LongConsumer

DoubleFunction<R>, DoublePredicate, DoubleConsumer

7. Collectors

Collectors.toList() â†’ convert stream to list

Collectors.toSet() â†’ convert stream to set

Collectors.toMap(keyMapper, valueMapper) â†’ convert to map

Collectors.joining(", ") â†’ join strings

Collectors.groupingBy(Function, downstream) â†’ group by property

Collectors.partitioningBy(Predicate) â†’ divide into true/false groups

8. Example with grouping & counting
String text = "hello world";

Map<Character, Long> freq = text.chars()
        .mapToObj(c -> (char) c)  
        .collect(Collectors.groupingBy(
                Function.identity(),
                Collectors.counting()
        ));

freq.forEach((ch, count) -> 
    System.out.println(ch + " -> " + count));


Output:

h -> 1
e -> 1
l -> 3
o -> 2
  -> 1
w -> 1
r -> 1
d -> 1

9. Parallel Streams

Enable parallelism using parallelStream().

Example:

numbers.parallelStream().forEach(System.out::println);


Be careful: results may be unordered.

10. Summary

Streams = functional way to process data.

Think in pipelines â†’ Source â†’ Intermediate â†’ Terminal.

Use functional interfaces (Function, Predicate, Consumer, Supplier).

Collectors are powerful for grouping, partitioning, and aggregating.

Prefer Streams for readability & declarative code.

ðŸš€ Text Diagram for Functional Interfaces
Function<T,R>    : (T) -> R
Predicate<T>     : (T) -> boolean
Consumer<T>      : (T) -> void
Supplier<T>      : () -> T
BiFunction<T,U,R>: (T, U) -> R

