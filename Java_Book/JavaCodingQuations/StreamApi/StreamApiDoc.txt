üìò Java Streams ‚Äì Complete Notes
1. What is a Stream?

A Stream is a sequence of elements supporting functional-style operations.

Introduced in Java 8.

Streams do not store data ‚Üí they work on data from collections, arrays, I/O channels, etc.

Streams are lazy ‚Üí operations are executed only when a terminal operation is invoked.

2. Stream Pipeline

A Stream pipeline consists of:

Source ‚Üí Intermediate Operations ‚Üí Terminal Operation


Source ‚Üí Collection, Array, or I/O.

Intermediate Operations ‚Üí Transform/Filter the stream (return another stream).

Terminal Operation ‚Üí Produces result (returns non-stream).

Example:
List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");

names.stream()                            // Source
     .filter(name -> name.length() > 3)   // Intermediate
     .map(String::toUpperCase)            // Intermediate
     .forEach(System.out::println);       // Terminal

3. Stream Diagram (Text-Based)
Collection/Array/IO Source
        ‚îÇ
        ‚ñº
+--------------------+
|   Stream pipeline  |
|--------------------|
| filter()           |
| map()              |
| sorted()           |
| distinct()         |
+--------------------+
        ‚îÇ
        ‚ñº
Terminal Operation (forEach, collect, reduce, count...)

4. Types of Streams

Stream<T> ‚Üí Generic stream of objects.

IntStream, LongStream, DoubleStream ‚Üí Primitive streams (avoid boxing overhead).

5. Key Operations
Intermediate (return a Stream)

filter(Predicate<T>) ‚Üí keep elements matching condition

map(Function<T,R>) ‚Üí transform elements

sorted() / sorted(Comparator)

distinct() ‚Üí remove duplicates

limit(n) ‚Üí take first n elements

skip(n) ‚Üí skip first n elements

Terminal (end pipeline, return non-stream)

forEach(Consumer<T>)

collect(Collectors.toList(), toSet(), toMap(), joining(), groupingBy())

reduce() ‚Üí aggregate into single value

count() ‚Üí count elements

anyMatch(), allMatch(), noneMatch()

6. Default Functional Interfaces (java.util.function)

Java 8 provides functional interfaces ‚Üí used in lambda expressions & streams.

Core Interfaces

Function<T, R> ‚Üí takes T, returns R

Example: map(String::length)

Predicate<T> ‚Üí takes T, returns boolean

Example: filter(x -> x > 10)

Consumer<T> ‚Üí takes T, returns nothing

Example: forEach(System.out::println)

Supplier<T> ‚Üí takes nothing, returns T

Example: Supplier<Date> now = Date::new

Primitive Specializations

IntFunction<R>, IntPredicate, IntConsumer

LongFunction<R>, LongPredicate, LongConsumer

DoubleFunction<R>, DoublePredicate, DoubleConsumer

7. Collectors

Collectors.toList() ‚Üí convert stream to list

Collectors.toSet() ‚Üí convert stream to set

Collectors.toMap(keyMapper, valueMapper) ‚Üí convert to map

Collectors.joining(", ") ‚Üí join strings

Collectors.groupingBy(Function, downstream) ‚Üí group by property

Collectors.partitioningBy(Predicate) ‚Üí divide into true/false groups

8. Example with grouping & counting
String text = "hello world";

Map<Character, Long> freq = text.chars()
        .mapToObj(c -> (char) c)  
        .collect(Collectors.groupingBy(
                Function.identity(),
                Collectors.counting()
        ));

freq.forEach((ch, count) -> 
    System.out.println(ch + " -> " + count));


Output:

h -> 1
e -> 1
l -> 3
o -> 2
  -> 1
w -> 1
r -> 1
d -> 1

9. Parallel Streams

Enable parallelism using parallelStream().

Example:

numbers.parallelStream().forEach(System.out::println);


Be careful: results may be unordered.

10. Summary

Streams = functional way to process data.

Think in pipelines ‚Üí Source ‚Üí Intermediate ‚Üí Terminal.

Use functional interfaces (Function, Predicate, Consumer, Supplier).

Collectors are powerful for grouping, partitioning, and aggregating.

Prefer Streams for readability & declarative code.

üöÄ Text Diagram for Functional Interfaces
Function<T,R>    : (T) -> R
Predicate<T>     : (T) -> boolean
Consumer<T>      : (T) -> void
Supplier<T>      : () -> T
BiFunction<T,U,R>: (T, U) -> R





The general form of groupingBy is:

Collectors.groupingBy(
    classifierFunction,   // (keyFunction)
    mapFactory,           // (condition for group storage ‚Üí which Map to use)
    downstreamCollector   // (howToStoreValues)
)

Breaking it down:

classifierFunction (keyFunction)

Decides the grouping key for each element.

Example: word -> word.charAt(0) groups by first character.

mapFactory (conditionForGroup)

Decides what kind of Map will store the groups.

Default: HashMap.

Example: TreeMap::new if you want sorted keys.

downstreamCollector (howToStoreValues)

Decides what to do with the values in each group.

Default: Collectors.toList().

Examples:

Collectors.toSet() ‚Üí stores as a Set.

Collectors.counting() ‚Üí counts elements.

Collectors.mapping(String::length, Collectors.toList()) ‚Üí stores lengths instead of the strings.

Example 1: All three arguments
Map<Character, Set<String>> grouped = words.stream()
    .collect(Collectors.groupingBy(
        word -> word.charAt(0),  // keyFunction ‚Üí group by first char
        TreeMap::new,            // map type ‚Üí TreeMap
        Collectors.toSet()       // store values as Set
    ));

System.out.println(grouped);


Output:

{a=[apple, apricot], b=[banana, blueberry], c=[cherry]}

Example 2: Only keyFunction
Map<Character, List<String>> grouped = words.stream()
    .collect(Collectors.groupingBy(word -> word.charAt(0)));


(Default: HashMap, List for values.)

So, your mental model is good:

(keyFunction, conditionForGroup, howToStoreValues)
is basically
(classifierFunction, mapFactory, downstreamCollector) in Java terms.

üëâ Do you want me to draw a little diagram/flow of data to show how elements move through these three steps?

You said:
how many arguments it take
ChatGPT said:

Good question üëç

Collectors.groupingBy(...) is overloaded in Java, so it can take 1, 2, or 3 arguments depending on what you need.

‚úÖ 1-argument version
groupingBy(classifierFunction)


Groups by the classifier function.

Uses HashMap by default.

Stores values in a List.

Example:

Map<Character, List<String>> result =
    words.stream().collect(Collectors.groupingBy(word -> word.charAt(0)));

‚úÖ 2-argument versions

There are two flavors:

classifier + downstreamCollector

groupingBy(classifierFunction, downstreamCollector)


‚Üí Still uses HashMap for keys, but you decide how to collect values.

Example:

Map<Character, Set<String>> result =
    words.stream().collect(Collectors.groupingBy(
        word -> word.charAt(0),
        Collectors.toSet()
    ));


classifier + mapFactory

groupingBy(classifierFunction, mapFactory)


‚Üí You decide the Map implementation, values stored in a List.

Example:

Map<Character, List<String>> result =
    words.stream().collect(Collectors.groupingBy(
        word -> word.charAt(0),
        TreeMap::new
    ));

‚úÖ 3-argument version
groupingBy(classifierFunction, mapFactory, downstreamCollector)


Full control over keys, map type, and value collector.

Example:

Map<Character, Set<String>> result =
    words.stream().collect(Collectors.groupingBy(
        word -> word.charAt(0),  // key
        TreeMap::new,            // use TreeMap
        Collectors.toSet()       // store as Set
    ));


üëâ So the answer is:

1 argument (classifier only)

2 arguments (classifier + downstream OR classifier + map type)

3 arguments (classifier + map type + downstream)

Do you want me to make a comparison table showing exactly what each version produces (map type + value type)?

You said:
but Collector.counting() is used
ChatGPT said:

Yes ‚Äî exactly üôÇ Collectors.counting() is one of those downstream collectors you can plug into groupingBy.

Let‚Äôs look at how it fits into the overloads:

Example with Collectors.counting()
List<String> words = List.of("apple", "banana", "cherry", "apricot", "blueberry");

Map<Character, Long> counts = words.stream()
    .collect(Collectors.groupingBy(
        word -> word.charAt(0),     // classifierFunction (key)
        Collectors.counting()       // downstreamCollector (value = count)
    ));

System.out.println(counts);

Output
{a=2, b=2, c=1}


Here‚Äôs what‚Äôs happening:

classifierFunction: word -> word.charAt(0) ‚Üí first letter of each word.

downstreamCollector: Collectors.counting() ‚Üí instead of collecting into a List or Set, it produces the count of elements in that group.

Result: a Map<Character, Long>.

Why it works

The default downstream of groupingBy is Collectors.toList().

But you can replace it with any collector: toSet(), counting(), summingInt(), mapping(), etc.

So Collectors.counting() is just another downstream collector.
